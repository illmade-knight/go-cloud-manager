package servicemanager

import (
	"context"
	"fmt"
	"os"
	"text/template"
	"time"

	"gopkg.in/yaml.v3"
)

const defaultProvisionedTemplate = `
# --- Provisioned Resources ---
# This file was generated by the ServiceManager. Do not edit manually.
# Timestamp: {{.Timestamp}}

ProvisionedTopics:
{{- range .Topics}}
  - Name: {{.Name}}
{{- end}}

ProvisionedSubscriptions:
{{- range .Subscriptions}}
  - Name: {{.Name}}
    Topic: {{.Topic}}
{{- end}}

ProvisionedGCSBuckets:
{{- range .GCSBuckets}}
  - Name: {{.Name}}
{{- end}}

ProvisionedBigQueryDatasets:
{{- range .BigQueryDatasets}}
  - Name: {{.Name}}
{{- end}}

ProvisionedBigQueryTables:
{{- range .BigQueryTables}}
  - Name: {{.Name}}
    Dataset: {{.Dataset}}
{{- end}}
`

// YAMLArchitectureIO implements the ArchitectureIO interface for local YAML files.
type YAMLArchitectureIO struct {
	template          *template.Template
	hubFilePath       string
	dataflowFilePaths []string
	outputFilePath    string
}

// NewYAMLArchitectureIO creates a new loader that reads and writes local YAML files.
func NewYAMLArchitectureIO(hubFilePath string, dataflowFilePaths []string, outputFilePath string) (*YAMLArchitectureIO, error) {
	tmpl, err := template.New("provisioned").Parse(defaultProvisionedTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse internal provisioned resources template: %w", err)
	}
	return &YAMLArchitectureIO{
		template:          tmpl,
		hubFilePath:       hubFilePath,
		dataflowFilePaths: dataflowFilePaths,
		outputFilePath:    outputFilePath,
	}, nil
}

// LoadArchitecture reads the full architecture from a local file path.
func (y *YAMLArchitectureIO) LoadArchitecture(ctx context.Context) (*MicroserviceArchitecture, error) {
	// Step 1: Read the main "hub" file for top-level environment info.
	hubData, err := os.ReadFile(y.hubFilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read hub architecture file '%s': %w", y.hubFilePath, err)
	}

	var arch MicroserviceArchitecture
	if err := yaml.Unmarshal(hubData, &arch); err != nil {
		return nil, fmt.Errorf("failed to unmarshal hub architecture YAML from '%s': %w", y.hubFilePath, err)
	}

	// Step 2: Initialize the Dataflows map.
	arch.Dataflows = make(map[string]ResourceGroup)

	// Step 3: Iterate through the configured dataflow file paths and load each one.
	for _, dfPath := range y.dataflowFilePaths {
		group, err := y.LoadResourceGroup(ctx, dfPath)
		if err != nil {
			return nil, fmt.Errorf("failed to load group '%s': %w", dfPath, err)
		}
		arch.Dataflows[group.Name] = *group
	}

	return &arch, nil
}

// LoadResourceGroup reads a single resource group from a local file path.
func (y *YAMLArchitectureIO) LoadResourceGroup(ctx context.Context, filePath string) (*ResourceGroup, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read resource group file '%s': %w", filePath, err)
	}

	group := &ResourceGroup{}
	if err := yaml.Unmarshal(data, group); err != nil {
		return nil, fmt.Errorf("failed to unmarshal resource group YAML from '%s': %w", filePath, err)
	}
	return group, nil
}

// WriteProvisionedResources writes the provisioned state to a local file path.
func (y *YAMLArchitectureIO) WriteProvisionedResources(ctx context.Context, resources *ProvisionedResources) error {
	file, err := os.Create(y.outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file at '%s': %w", y.outputFilePath, err)
	}
	defer file.Close()

	// We can enrich the data before writing
	type templateData struct {
		*ProvisionedResources
		Timestamp string
	}

	data := templateData{
		ProvisionedResources: resources,
		Timestamp:            time.Now().UTC().Format(time.RFC3339),
	}

	if err := y.template.Execute(file, data); err != nil {
		return fmt.Errorf("failed to execute template and write to '%s': %w", y.outputFilePath, err)
	}
	return nil
}
